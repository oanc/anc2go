package org.anc.togo.dsl

// The scriptText would typically be stored in an external file
// and parsed with GroovyShell.parse(File). We include script
// text here for testing purposes.

class Directory
{
   // Directory id.  Uses the name did so it does not conflict with the automatically
   // id generated by GORM.
   String did
	String name
	String path
	String textClass
	List<Directory> directories = []
	
	void print()
	{
		print('    ')
	}
	
	void print(String indent)
	{
      println "${indent}ID   : ${did}"
		println "${indent}Name : ${name}" 
		println "${indent}Path : ${path}" 
		println "${indent}Class: ${textClass}"
		directories.each { dir ->
			dir.print(indent + '    ') 
		println ""
		}
	}
}

class CorporaDelegate 
{
	def corpora = []
	void corpus(Closure cl)
	{
		CorpusDelegate delegate = new CorpusDelegate()
		cl.delegate = delegate
		cl.resolveStrategy = Closure.DELEGATE_FIRST
		cl()
		corpora << delegate.corpus
	}
}

class CorpusDelegate
{
	def corpus = [:]
	void name(String name)
	{
      corpus.cid = name.replaceAll(' ', '')
		corpus.name = name
	}
	
	void version(String version)
	{
		corpus.version = version
	}
	
	void root(String path)
	{
		corpus.root = path
	}
	
	void directories(Closure cl)
	{
		DirectoriesDelegate delegate = new DirectoriesDelegate()
		cl.delegate = delegate
		cl.resolveStrategy = Closure.DELEGATE_FIRST
		cl()
		corpus.directories = delegate.directories
	}
}

class DirectoriesDelegate
{
	List<Directory> directories = []
	
	void directory(Closure cl) 
	{
		DirectoryDelegate delegate = new DirectoryDelegate()
		cl.delegate = delegate
		cl.resolveStrategy = Closure.DELEGATE_FIRST
		cl()
		directories << delegate.directory	
	}
}

class DirectoryDelegate
{
	Directory directory = new Directory()
	
	void name(String name)
	{
      directory.did = name.replaceAll(' ', '')
		directory.name = name
	}
	
	void path(String path)
	{
		directory.path = path
	}
	
	void textClass(String textClass)
	{
		directory.textClass = textClass
	}
	
	void directory(Closure cl)
	{
		DirectoryDelegate delegate = new DirectoryDelegate()
		cl.delegate = delegate
		cl.resolveStrategy = Closure.DELEGATE_FIRST
		cl()
		directory.directories << delegate.directory	
	}
}

void run(String name, String text)
{
	println "Running ${name}"
	def corpora = []
	Script script = new GroovyShell().parse(text)
	ExpandoMetaClass meta = new ExpandoMetaClass(script.class, false)
	meta.corpora = { Closure cl ->
		CorporaDelegate delegate = new CorporaDelegate()	
		cl.delegate = delegate
		cl.resolveStrategy = Closure.DELEGATE_FIRST
		cl()
		corpora = delegate.corpora
	}
	
	meta.initialize()
	script.metaClass = meta
	script.run()
	
	corpora.each { corpus ->
		println "Name   : ${corpus.name}"
		println "Version: ${corpus.version}"
		println "Root   : ${corpus.root}"
		if (corpus.directories)
		{
			println "Directories"
			corpus.directories.each { dir ->
				//println "Class: ${dir.class.name}"
				dir.print()
				//println "   Name : ${dir?.name}"
				//println "   Path : ${dir?.path}"
				//println "   Class: ${dir?.textClass}"
				println ""
			}
		}
		println ""
	}
	println "Done."
}

public static List getCorporaListForScript(String scriptText)
{
   def corpora = []
   Script script = new GroovyShell().parse(scriptText)
   ExpandoMetaClass meta = new ExpandoMetaClass(script.class, false)
   meta.corpora = { Closure cl ->
      CorporaDelegate delegate = new CorporaDelegate()
      cl.delegate = delegate
      cl.resolveStrategy = Closure.DELEGATE_FIRST
      cl()
      corpora = delegate.corpora
   }
   
   meta.initialize()
   script.metaClass = meta
   script.run()
   
   return corpora
}

//run('test1', test1)
//run('test2', test2)
//run('test3', test3)
//run('test script', scriptText)
def corpora = getCorporaListForScript(scriptText)
corpora.each { corpus ->
   println "name: ${corpus.name}" 
   println "root: ${corpus.root}"
   def dirs = corpus.directories
   dirs.each { dir ->
      println "\tdir name: ${dir.name}"
      if (dir.directories)
      {
         def subDirs = dir.directories
         subDirs.each {
            println "\t\tdir name: ${it.name}"
         }
      }
   }
}